var csv_element = document.getElementById('csvUpload');
var rawCSVArray = []
var csvArray = []
var csvScoresbyLocationDict = {}
var csvGeoJson = {}

var exportRawCSVArray = []
var exportCSVArray = []

//Minimize attribute table
function closeAttributeTable(){
	document.getElementById('attributetable').style.height='30px';
	document.getElementById('attributes').style.height='0px';
	document.getElementById('map').style.bottom='30px';
	document.getElementById('attributecontrol').onclick=openAttributeTable;
	document.getElementById('attributecontrol').innerHTML = "Open"
	map.resize()
}

//Maximize attribute table
function openAttributeTable(){
	document.getElementById('attributetable').style.height='200px';
	document.getElementById('attributes').style.height='170px';
	document.getElementById('map').style.bottom='200px';
	document.getElementById('attributecontrol').onclick=closeAttributeTable;
	document.getElementById('attributecontrol').innerHTML = "Close"
	map.resize()
}

//Count the number of controls that are checked. 
function countChecked() {
	count = 0
	analytes = Object.keys(analytesDict)
	for (var i = 0; i < Object.keys(analytesDict).length; i++) {
		if(document.getElementById(analytesDict[analytes[i]]["control"]).checked){
			count++;
		}
	}
	return count;
}

//Zoom to coordinates
function flyButton(coords) {
	var btn = document.createElement('button');
	btn.type = "button";
	btn.className = "zoombutton";
	btn.innerHTML = "ZoomTo";
	btn.addEventListener('click', () => {
			map.flyTo({
			center: coords,
			zoom: 18,
			speed: 4,
			minZoom: 15,
			essential: true // this animation is considered essential with respect to prefers-reduced-motion
		});
	});
	return btn
}

//Populate the attribute table. Header rows are given th tags. Body rows are given zoom buttons based on coordinates.
function populateAttributeTable(coords, row, divId) {
	
	var tableRef = document.getElementById(divId);
	if(tableRef && row){	
		var newRow = tableRef.insertRow();
		
		if(coords){
			var newCell = newRow.insertCell();
			newCell.appendChild(flyButton(coords));	
		}
		
		for (var i = 0; i < row.length; i++) {
			var newCell = newRow.insertCell();
			//var cellText = String(row[i]).split(' ').join('_').substring(0,25)
			var cellText = String(row[i])
			
			if(divId == "attributesHeader"){
				newCell.outerHTML = "<th>"+String(cellText)+"</th>"
			}else{
				var newText = document.createTextNode(cellText);
				newCell.appendChild(newText);				
			}
		}	
	}
}

//Summarize the uploaded CSV data by location and assign vulnerability scores
function summarizeCSVbyLocation(rawCSVArray) {

	var headers = rawCSVArray[0]
	var lat_ind = headers.indexOf('Latitude')
	var long_ind = headers.indexOf('Longitude')
	
	assignCalcIndices(headers)
	getMaxAnalyteValues()

	var csvLocationDict = {}
	var summaryCSVArray = [["Records at Location"].concat(headers)]
	csvScoresbyLocationDict = {}
	
	//Create objects with coordinates keys to categorize data by location
	for (var count = 1; count < rawCSVArray.length; count++) {
		var row = rawCSVArray[count]	
		if(Number.isFinite(parseFloat(row[long_ind])) && Number.isFinite(parseFloat(row[lat_ind]))){
			coordskey = String(parseFloat(row[long_ind]))+","+String(parseFloat(row[lat_ind]))
			csvLocationDict[coordskey] = {}
			csvScoresbyLocationDict[coordskey] = {"mean":NaN,"count":NaN,"median":NaN,"stdev":NaN,"skewness":NaN,"scoreList":[]}
			for (var i = 0; i < headers.length; i++) {
				csvLocationDict[coordskey][headers[i]] = []
			}
		}
	}
	
	//Fill objects with csv data and vulnerability scores
	var riskArray = []
	exportRawCSVArray =[["Vulnerability Score"].concat(headers)]
	for (var count = 1; count < rawCSVArray.length; count++) {
		var row = rawCSVArray[count]	
		var vulnerabilityScore = calculateRisk(row)
		if(Number.isFinite(parseFloat(row[long_ind])) && Number.isFinite(parseFloat(row[lat_ind]))){
			coordskey = String(parseFloat(row[long_ind]))+","+String(parseFloat(row[lat_ind]))
			for (var i = 0; i < headers.length; i++) {
				csvLocationDict[coordskey][headers[i]].push(row[i])
				
				
			}
			
			if(vulnerabilityScore){
				csvScoresbyLocationDict[coordskey]["scoreList"].push(vulnerabilityScore)
				riskArray.push(vulnerabilityScore)
			}
		}
		exportRawCSVArray.push([vulnerabilityScore].concat(row))
	}
	
	//Perform the stat summaries that show on the data bar
	summaryStats(riskArray)
	var uniquecoords = Object.keys(csvLocationDict)

	//Create summary csv array to be shown in attribute table and map geojson
	for (var i = 0; i < uniquecoords.length; i++) {
		var outputRow = [csvLocationDict[uniquecoords[i]][headers[0]].length]
		for (var j = 0; j < headers.length; j++) {
			var arrayToSummarize = csvLocationDict[uniquecoords[i]][headers[j]]
			var summaryValue = arrayToSummarize[0]
			if(analyteIndices.has(j)){
				summaryValue = round(arrayToSummarize.reduce((a, b) => parseFloat(a) + parseFloat(b)) / arrayToSummarize.length)
			}
			outputRow.push(summaryValue)
		}
		summaryCSVArray.push(outputRow)
	}	

	//Calculate score statistics by location
	var uniquecoords = Object.keys(csvScoresbyLocationDict)
	for (var i = 0; i < uniquecoords.length; i++) {
		var riskArray = csvScoresbyLocationDict[uniquecoords[i]]["scoreList"]
		if(riskArray.length > 0){
			csvScoresbyLocationDict[uniquecoords[i]]["count"] = round(riskArray.length)
			csvScoresbyLocationDict[uniquecoords[i]]["mean"] = round(riskArray.reduce((a, b) => a + b) / riskArray.length)
			csvScoresbyLocationDict[uniquecoords[i]]["median"] = round(calculateMedian(riskArray))
			csvScoresbyLocationDict[uniquecoords[i]]["stdev"] = round(Math.sqrt(riskArray.map(x => Math.pow(x - round(riskArray.reduce((a, b) => a + b) / riskArray.length), 2)).reduce((a, b) => a + b) / riskArray.length))
			csvScoresbyLocationDict[uniquecoords[i]]["skewness"] = round(3*(round(riskArray.reduce((a, b) => a + b) / riskArray.length)-calculateMedian(riskArray))/Math.sqrt(riskArray.map(x => Math.pow(x - round(riskArray.reduce((a, b) => a + b) / riskArray.length), 2)).reduce((a, b) => a + b) / riskArray.length))
		}
	}	
	
	return summaryCSVArray

}

//Convert csv array into geojson for mapping
function convertCSVtoGeoJSON() {
	if(countChecked()!=0){
		csvArray = summarizeCSVbyLocation(rawCSVArray)
		
		//Get CSV headers
		var headers = csvArray[0]
		var lat_ind = headers.indexOf('Latitude')
		var long_ind = headers.indexOf('Longitude')

		//Use headers to identify indices of analytes in the csv
		assignCalcIndices(headers)
		
		//Reset the attribute tables
		document.getElementById("attributesHeader").innerHTML = ""
		document.getElementById("attributesBody").innerHTML = ""
		
		//Recreate the headers with "Average" qualifier added to analyte headers
		var headersedit = []
		for (var j = 0; j < headers.length; j++) {
			if(analyteIndices.has(j)){
				headersedit.push("Average "+headers[j])
			}else{
				headersedit.push(headers[j])
			}			
		}
		
		csvArray[0] = headersedit
		headers = csvArray[0]
		populateAttributeTable(null,["Zoom","Mean Vulnerability Score"].concat(headers), "attributesHeader")
		exportCSVArray = [["Mean Vulnerability Score"].concat(headers)]
		
		//Create geojson
		csvGeoJson = {"type": "FeatureCollection","features":[]}
		sortingArray = []
		for (var count = 1; count < csvArray.length; count++) {
			var row = csvArray[count]
			if(Number.isFinite(parseFloat(row[long_ind])) && Number.isFinite(parseFloat(row[lat_ind]))){
				coords = [parseFloat(row[long_ind]), parseFloat(row[lat_ind])]
				coordskey = String(parseFloat(row[long_ind]))+","+String(parseFloat(row[lat_ind]))
				//Assign mean vulnerability of location to geojson record
				var vulnerabilityScore = csvScoresbyLocationDict[coordskey]["mean"]
				if(vulnerabilityScore){
					featureGeoJson = {"type": "Feature",
										"geometry": {"type": "Point", "coordinates": coords},
										"properties": {"Mean Vulnerability Score":vulnerabilityScore}
									}		
					for (var i = 0; i < row.length; i++) {
						featureGeoJson["properties"][headers[i]] = row[i]
					}
					featureGeoJson["properties"]["coordskey"] = coordskey
					csvGeoJson["features"].push(featureGeoJson)
				}
				sortingArray.push([coords].concat([vulnerabilityScore],row))
				exportCSVArray.push([vulnerabilityScore].concat(row))
			}
		}
		var sortedArray = sortingArray.sort(function(a, b) {return b[1] - a[1];});
		for (var i = 0; i < sortedArray.length; i++) {
			populateAttributeTable(sortedArray[i][0], sortedArray[i].slice(1,sortedArray[i].length), "attributesBody")
		}
	}else{
		console.log("No analytes checked")
	}
	
}

function recalculateGeoJSON() {
	if (csvArray.length!=0){
		convertCSVtoGeoJSON()
		visualizeWQData();
	}else{
		alert("No CSV data added")
	}
}

document.getElementById('csvUpload').addEventListener('change', function(){
  document.getElementById('csvUpload-file-chosen').textContent = this.files[0].name
})

csv_element.onchange = function(){
  //Reset box shadows
  for (var i = 0; i < Object.keys(analytesDict).length; i++) {
	  document.getElementById(analytesDict[Object.keys(analytesDict)[i]]["control"]).style.removeProperty("box-shadow")
  }
  //Validate CSV
  //var regex = /^([a-zA-Z0-9\s_\\.\-:])+(.csv|.txt)$/;
  //if (regex.test(csv_element.value.toLowerCase())) {
	if (csv_element.value.endsWith(".csv")) {  
	  console.log("Uploaded CSV with size: "+String(csv_element.size))
	  if (typeof (FileReader) != "undefined") {
		  if(csv_element.size < 200*1024*1024){
				  var myReader = new FileReader();
				  myReader.onload = function(e) {
					var content = myReader.result;
					rawCSVArray = content.split(/\r?\n|\r/);
					for (var count = 0; count < rawCSVArray.length; count++) {
						rawCSVArray[count] = rawCSVArray[count].split(",")
					}
					assignInitialChecks()
					convertCSVtoGeoJSON()
					visualizeWQData()
				  }
					myReader.readAsText(csv_element.files[0]);

		  }else{
			  alert("CSV file must be less than 200 MB")
		  }
	  }else{
		  alert("This browser does not support HTML5.");
	  }
  }else{
	  alert("Please upload a valid CSV file.");
  }
  
  //Reset csv element value so csv can be reuploaded
  csv_element.value = ''
};

